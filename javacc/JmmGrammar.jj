PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES = false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< LOWER_THAN : "<" > |
	< EQUAL : "=" > |
    < AND : "&&" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_SQUARE_PAREN : "[" > |
	< CLOSE_SQUARE_PAREN : "]" > |
	< OPEN_CURLY_PAREN : "{" > |
	< CLOSE_CURLY_PAREN : "}" > |
	< COMMA : "," > |
	< DOUBLE_DOT : ":" > |
	< DOT : "." > |
	< END_EXPRESSION : ";" > |
	< NOT : "!" > |
	< IMPORT : "import" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< BOOLEAN : "boolean" > |
	< INT : "int" > |
	< PUBLIC : "public" > |
	< RETURN : "return" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< STRING : "String" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< LENGTH : "length" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< NULL : "null" > |
	< INTEGER : (["0" - "9"])+ > |
	< IDENTIFIER : (["A" - "Z", "a" - "z"] | "_" | "$") ((["A" - "Z", "a" - "z", "0" - "9"] | "_" | "$"))* >
;

Start : Program <EOF> ;

Assignment #void:
    (< IDENTIFIER > ({jjtThis.put("name", lastConsumedToken.getImage()); }) #Id < EQUAL > AdditiveExpression) ({jjtThis.put("op", "assign");}) #BinOp(2)
;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< INTEGER > |
	< MINUS> Factor |
	< OPEN_PAREN > AdditiveExpression < CLOSE_PAREN >
;

Program :
    ImportDeclaration ClassDeclaration < EOF >
;

ImportDeclaration :
    (
        < IMPORT > < IDENTIFIER > ( < DOT > < IDENTIFIER > )* < END_EXPRESSION >
    )*
;

Type :
    < INT > (< OPEN_SQUARE_PAREN >  < CLOSE_SQUARE_PAREN >)? |
    < BOOLEAN > |
    < IDENTIFIER >
;

ClassDeclaration :
    < CLASS > < IDENTIFIER > (< EXTENDS > < IDENTIFIER >)? < OPEN_CURLY_PAREN > (VarDeclaration)* (MethodDeclaration)* < CLOSE_CURLY_PAREN >
;

VarDeclaration :
    Type < IDENTIFIER > < END_EXPRESSION >
;

MethodDeclaration:
    < PUBLIC > (Type < IDENTIFIER > < OPEN_PAREN > (Type < IDENTIFIER > (< COMMA > Type < IDENTIFIER >)* )? < CLOSE_PAREN > < OPEN_CURLY_PAREN > (SCAN 2 (VarDeclaration)*
    (Statement)*) < RETURN > Expression < END_EXPRESSION > < CLOSE_CURLY_PAREN > | < STATIC > < VOID > < MAIN > < OPEN_PAREN > < STRING > < OPEN_SQUARE_PAREN >
    < CLOSE_SQUARE_PAREN > < IDENTIFIER > < CLOSE_PAREN > < OPEN_CURLY_PAREN > (SCAN 2 (VarDeclaration)* (Statement)*) < CLOSE_CURLY_PAREN > )
;

Statement:
    < OPEN_CURLY_PAREN > (Statement)* < CLOSE_CURLY_PAREN > |
    < IF > < OPEN_PAREN > Expression < CLOSE_PAREN > Statement < ELSE > Statement |
    < WHILE > < OPEN_PAREN > Expression < CLOSE_PAREN > Statement |
    (SCAN 2 Expression < END_EXPRESSION > |
    < IDENTIFIER > ( < EQUAL > Expression < END_EXPRESSION > | < OPEN_SQUARE_PAREN > Expression < CLOSE_SQUARE_PAREN > < EQUAL > Expression < END_EXPRESSION > ))
;

ExpressionFirst:
    < INTEGER > | < FALSE > | < TRUE > | < IDENTIFIER > | < THIS > | < NEW > | < NOT > | < OPEN_PAREN >
;

Expression:
    ExpressionFirst (
                      ( < AND > | < LOWER_THAN > | < PLUS > | < MINUS > | < TIMES > | < DIVIDE >) Expression |
                      < OPEN_SQUARE_PAREN > Expression < CLOSE_SQUARE_PAREN > |
                      < DOT > (< LENGTH > | < IDENTIFIER > < OPEN_PAREN > ( Expression (< COMMA > Expression )* )? < CLOSE_PAREN > ) |
                      < INT > < OPEN_SQUARE_PAREN > Expression < CLOSE_SQUARE_PAREN > |
                      (SCAN 2 < IDENTIFIER > < OPEN_PAREN > < CLOSE_PAREN > |
                      Expression ( < CLOSE_PAREN > )?)
                    )*
;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}

// Injections for the implementation of JmmNode
// Since this is injected into Token, it affects only terminals
INJECT Token :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

		throw new RuntimeException("Cannot add child nodes to a Token.");
    }

    @Override
    public List<String> getAttributes() {
        return SpecsCollections.concat("image", super.getAttributes());
    }

    @Override
    public String get(String attribute) {
		if(attribute.equals("image")) {
			return getImage();
		}

        return super.get(attribute);
    }
}

